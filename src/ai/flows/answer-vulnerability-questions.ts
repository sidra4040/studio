
'use server';
/**
 * @fileOverview A vulnerability management chatbot that uses the Medtronic GPT and can query DefectDojo.
 *
 * - answerVulnerabilityQuestions - A function that answers questions using Medtronic GPT, with the ability to call tools.
 * - AnswerVulnerabilityQuestionsInput - The input type for the answerVulnerabilityQuestions function.
 * - AnswerVulnerabilityQuestionsOutput - The return type for the answerVulnerabilityQuestionsOutput function.
 */

import {z} from 'genkit';
import { getFindings, analyzeVulnerabilityData, getTotalFindingCount, getProductList } from '@/services/defectdojo';


const AnswerVulnerabilityQuestionsInputSchema = z.object({
  question: z.string().describe('The question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsInput = z.infer<typeof AnswerVulnerabilityQuestionsInputSchema>;

const AnswerVulnerabilityQuestionsOutputSchema = z.object({
  answer: z.string().describe('The answer to the question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsOutput = z.infer<typeof AnswerVulnerabilityQuestionsOutputSchema>;

// In-memory cache for the Medtronic GPT token
const tokenCache = {
  apiToken: process.env.MEDTRONIC_GPT_API_TOKEN || null,
  expiresAt: 0, // A value of 0 forces a refresh on the first call
};

/**
 * Refreshes the Medtronic GPT API token.
 * This function is called when the current token is missing or expired.
 */
async function refreshMedtronicGptToken(): Promise<string> {
  const REFRESH_URL = process.env.MEDTRONIC_GPT_REFRESH_URL;
  const SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;
  const REFRESH_TOKEN = process.env.MEDTRONIC_GPT_REFRESH_TOKEN;
  const currentApiToken = tokenCache.apiToken; // Use the possibly expired token for the refresh call

  if (!REFRESH_URL || !SUBSCRIPTION_KEY || !REFRESH_TOKEN || !currentApiToken) {
    throw new Error('Missing Medtronic GPT refresh credentials. Please set MEDTRONIC_GPT_REFRESH_URL, MEDTRONIC_GPT_SUBSCRIPTION_KEY, MEDTRONIC_GPT_REFRESH_TOKEN, and an initial MEDTRONIC_GPT_API_TOKEN in your .env file.');
  }
  
  try {
    console.log('[Medtronic GPT] Token is expired or missing. Refreshing...');
    const response = await fetch(REFRESH_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': SUBSCRIPTION_KEY,
        'api-token': currentApiToken,
        'refresh-token': REFRESH_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[Medtronic GPT] Token refresh failed: HTTP status ${response.status}. ${errorText}`);
      tokenCache.apiToken = null;
      tokenCache.expiresAt = 0;
      throw new Error(`Failed to refresh token: HTTP status ${response.status}. ${errorText}`);
    }
    
    const data = await response.json();
    const newApiToken = data.apiToken || data.token;
    
    if (!newApiToken) {
        throw new Error("New API token not found in the refresh response payload.");
    }
    
    console.log('[Medtronic GPT] Successfully refreshed token.');
    tokenCache.apiToken = newApiToken;
    // Set expiry to 3600 seconds (1 hour) from now, with a 60-second buffer
    tokenCache.expiresAt = Date.now() + (3600 - 60) * 1000;
    
    return newApiToken;
  } catch (error) {
    console.error('[Medtronic GPT] Exception during token refresh:', error);
    tokenCache.apiToken = null;
    tokenCache.expiresAt = 0;
    throw error;
  }
}

/**
 * Retrieves a valid Medtronic GPT API token, refreshing it if necessary.
 */
async function getValidMedtronicGptToken(): Promise<string> {
  const isTokenExpired = Date.now() >= tokenCache.expiresAt;
  
  if (tokenCache.apiToken && !isTokenExpired) {
    return tokenCache.apiToken;
  }
  
  return await refreshMedtronicGptToken();
}

const tools = [
  {
    type: 'function',
    function: {
      name: 'get_product_list',
      description: "Get a list of all available product names from DefectDojo. Use this when the user asks to 'list all products' or 'what products do you know about?'.",
      parameters: {
        type: 'object',
        properties: {},
        required: [],
      },
    },
  },
  {
    type: 'function',
    function: {
      name: 'get_findings',
      description: "Get a list of vulnerability findings from DefectDojo. This is your primary tool for retrieving raw data. Use this for specific, direct questions asking to 'list', 'show', 'find', 'count', or 'what is'. For a simple count (e.g., 'how many critical'), you can call this tool and then use the 'totalCount' from the result.",
      parameters: {
        type: 'object',
        properties: {
          productName: { type: 'string', description: "(Optional) The name of a single product to filter by (e.g., 'MCLS'). If omitted, searches across all products." },
          toolName: { type: 'string', description: "(Optional) The name of the tool/scanner to filter by (e.g., 'DependencyTrack', 'SonarQube')." },
          severity: { type: 'string', description: "(Optional) The severity level to filter by (e.g., 'Critical', 'High')." },
          cve: { type: 'string', description: "(Optional) A specific CVE to search for." },
          componentName: { type: 'string', description: "(Optional) The name of a component/library to filter by (e.g., 'openssl')." },
          limit: { type: 'number', description: 'The maximum number of findings to return. Defaults to 10 unless the user asks for a specific count.' },
        },
        required: [],
      },
    },
  },
  {
      type: 'function',
      function: {
          name: 'analyze_vulnerability_data',
          description: "Performs advanced analysis and aggregation on vulnerability data. Use this for complex, high-level questions about 'which is best/worst', 'compare', 'what is the risk', 'what is the trend', or 'prioritize'. Do not use for simple 'list' or 'count' questions.",
          parameters: {
              type: 'object',
              properties: {
                  productName: { type: 'string', description: "(Optional) The name of a single product OR a comma-separated list of product names to focus the analysis on. If omitted, the analysis will cover ALL products." },
                  analysisType: {
                      type: 'string',
                      description: 'The type of analysis to perform.',
                      enum: [
                          'component_risk', // For questions like "Which component should I fix first?" or "Which component has the most critical vulnerabilities?"
                          'tool_comparison', // For "Compare tool X and tool Y" or "Which tool finds more issues?"
                          'vulnerability_age', // For "Which is the oldest vulnerability?"
                          'cross_product_component_usage', // For "Which component is shared and vulnerable across products X and Y?"
                          'product_risk', // For "Which product has the highest number of Critical vulnerabilities?"
                          'cve_analysis' // For questions like "What are the most common CVEs?"
                      ]
                  },
                  severities: {
                      type: 'array',
                      items: { type: 'string' },
                      description: "A list of severities to include in the analysis (e.g., ['Critical', 'High'])."
                  },
                  limit: { type: 'number', description: 'The number of results to return for ranked lists (e.g., top 5 components). Default is 5.' }
              },
              required: ['analysisType'],
          },
      },
  },
];


export async function answerVulnerabilityQuestions(input: AnswerVulnerabilityQuestionsInput): Promise<AnswerVulnerabilityQuestionsOutput> {
  const MEDTRONIC_GPT_API_URL = process.env.MEDTRONIC_GPT_API_URL;
  const MEDTRONIC_GPT_SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;

  if (!MEDTRONIC_GPT_API_URL || !MEDTRONIC_GPT_SUBSCRIPTION_KEY) {
    return {
      answer: "Error: Medtronic GPT API credentials are not configured. Please set the MEDTRONIC_GPT_API_URL and MEDTRONIC_GPT_SUBSCRIPTION_KEY environment variables in your .env file."
    };
  }
  
  try {
    const validApiToken = await getValidMedtronicGptToken();

    const messages: any[] = [
        {
          role: 'system',
          content: `You are DojoGPT, an expert vulnerability management assistant. Your primary goal is to provide precise, actionable answers to user questions about security vulnerabilities by calling the tools you have been given.

**Core Task & Tool Usage Philosophy:**
- **Your ONLY way to get information is by calling tools.** You have no prior knowledge.
- **Select the right tool for the job.** You have three tools: \`get_product_list\`, \`get_findings\`, and \`analyze_vulnerability_data\`.
- **Think step-by-step.** First, understand the user's question. Second, choose the single best tool to answer it. Third, call the tool with the correct arguments. Fourth, present the result to the user.
- **If a tool returns no results, state that clearly.** For example: "I found no critical vulnerabilities for product X." or "I found no results for tool SonarQube in product MCLH." Do not make up answers or say you cannot perform the action. Just report that the result was empty.

**Tool Selection Guide (Examples):**

*   **User asks to list products:** "what products are there?" or "list all products"
    *   **Correct Tool:** \`get_product_list()\`
    *   **Your Action:** Call the tool and present the returned list as a simple bulleted list.

*   **User asks for a simple count:** "how many critical vulns in MCLH?"
    *   **Correct Tool:** \`get_findings({productName: 'MCLH', severity: 'Critical'})\`
    *   **Your Action:** Call the tool and report the \`totalCount\` from the result. For example: "There are 15 critical vulnerabilities in MCLH."

*   **User asks for a simple list:** "show me the 5 most recent findings for CLEM"
    *   **Correct Tool:** \`get_findings({productName: 'CLEM', limit: 5})\`
    *   **Your Action:** Call the tool and list the findings from the result.

*   **User asks a complex analytical question:** "which component in MCLS is the riskiest?" or "compare tools in CLEM"
    *   **Correct Tool:** \`analyze_vulnerability_data({productName: 'MCLS', analysisType: 'component_risk'})\`
    *   **Your Action:** Call the tool and summarize the analytical result it provides.

*   **User asks for a cross-product comparison:** "Which component is shared between CLEM and MCLH?"
    *   **Correct Tool:** \`analyze_vulnerability_data({productName: 'CLEM,MCLH', analysisType: 'cross_product_component_usage'})\`

*   **User asks for common CVEs:** "what are the most common cves"
    *   **Correct Tool:** \`analyze_vulnerability_data({analysisType: 'cve_analysis'})\`

**Response Formatting Rules:**
- Use Markdown for all responses.
- Use **bold text** for headings and key terms. DO NOT use Markdown headers ('#', '##').
- When listing findings from \`get_findings\`, present them in a numbered list. For each finding, include the **Title**, **Severity**, **Component**, **CVE**, **CWE**, and **Tool**.
- When presenting analysis from \`analyze_vulnerability_data\`, provide a clear summary of the results.
- When listing products from \`get_product_list\`, use a simple bulleted list.

**Final Answer Generation:**
- After getting data from a tool, present that data clearly to the user.
- Do not add conversational fluff. Be direct and data-driven.`,
        },
        {
          role: 'user',
          content: input.question,
        },
    ];

    const requestBody = {
      messages,
      tools,
      tool_choice: 'auto',
    };

    const response = await fetch(MEDTRONIC_GPT_API_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
        'api-token': validApiToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      if (response.status === 401) {
          console.error('[Medtronic GPT] Authentication error (401). Token may be invalid.');
          tokenCache.expiresAt = 0; // Force a token refresh on the next attempt
          return {
              answer: `Authentication error with Medtronic GPT (HTTP 401). The API token might be invalid. A refresh will be attempted on the next request. Details: ${errorText}`
          };
      }
      return {
          answer: `Error calling Medtronic GPT: HTTP status ${response.status}. ${errorText}`
      };
    }

    const data = await response.json();
    const responseMessage = data.choices && data.choices[0] && data.choices[0].message;

    // Check if the model wants to call a tool
    if (responseMessage && responseMessage.tool_calls) {
        messages.push(responseMessage);
        
        for (const toolCall of responseMessage.tool_calls) {
            const functionName = toolCall.function.name;
            const args = JSON.parse(toolCall.function.arguments);
            let toolResponseContent = '';

            try {
                 switch (functionName) {
                    case 'get_findings':
                        // Handle simple counts separately for efficiency
                        if (args.limit === 1 && !args.cve && !args.componentName) {
                             const countResult = await getTotalFindingCount(args.productName, args.severity);
                             toolResponseContent = JSON.stringify({ totalCount: countResult.count, findings: [] });
                        } else {
                            const findingsResult = await getFindings(args);
                            toolResponseContent = JSON.stringify(findingsResult);
                        }
                        break;
                    case 'analyze_vulnerability_data':
                        const analysisResult = await analyzeVulnerabilityData(args.analysisType, args.productName, args.severities, args.limit);
                        toolResponseContent = JSON.stringify(analysisResult);
                        break;
                    case 'get_product_list':
                        const productList = await getProductList();
                        toolResponseContent = JSON.stringify(productList);
                        break;
                    default:
                        toolResponseContent = JSON.stringify({ error: `The tool '${functionName}' is not recognized.` });
                }
            } catch (e) {
                const error = e instanceof Error ? e.message : String(e);
                console.error(`[Tool Execution] Error calling tool '${functionName}':`, error);
                toolResponseContent = JSON.stringify({ error: `An error occurred while running the tool: ${error}` });
            }

            messages.push({
                tool_call_id: toolCall.id,
                role: 'tool',
                name: functionName,
                content: toolResponseContent,
            });
        }
            
            const secondRequestBody = { messages, tools, tool_choice: 'auto' };
            const secondResponse = await fetch(MEDTRONIC_GPT_API_URL, {
                method: 'POST',
                headers: {
                    'api-version': '3.0',
                    'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
                    'api-token': validApiToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(secondRequestBody),
            });
            
            if (!secondResponse.ok) {
              const errorText = await secondResponse.text();
              return { answer: `Error processing tool result: HTTP status ${secondResponse.status}. ${errorText}` };
            }
            
            const secondData = await secondResponse.json();
            const finalAnswer = secondData.choices && secondData.choices[0] && secondData.choices[0].message && secondData.choices[0].message.content
                ? secondData.choices[0].message.content
                : "I couldn't process the data from DefectDojo.";

            return { answer: finalAnswer };
    }


    const answer = responseMessage && responseMessage.content
      ? responseMessage.content
      : "I'm sorry, I received an unexpected response from Medtronic GPT.";

    return { answer };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('[answerVulnerabilityQuestions] Top-level exception:', errorMessage);
    return {
      answer: `There was a problem processing your request. Please check your configuration. Details: ${errorMessage}`
    };
  }
}
