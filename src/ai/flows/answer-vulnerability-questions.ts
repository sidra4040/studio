'use server';
/**
 * @fileOverview A vulnerability management chatbot that uses the Medtronic GPT and can query DefectDojo.
 *
 * - answerVulnerabilityQuestions - A function that answers questions using Medtronic GPT, with the ability to call tools.
 * - AnswerVulnerabilityQuestionsInput - The input type for the answerVulnerabilityQuestions function.
 * - AnswerVulnerabilityQuestionsOutput - The return type for the answerVulnerabilityQuestions function.
 */

import {z} from 'genkit';
import { getFindings, getProductList, getVulnerabilityCountBySeverity, getEngagementList } from '@/services/defectdojo';


const AnswerVulnerabilityQuestionsInputSchema = z.object({
  question: z.string().describe('The question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsInput = z.infer<typeof AnswerVulnerabilityQuestionsInputSchema>;

const AnswerVulnerabilityQuestionsOutputSchema = z.object({
  answer: z.string().describe('The answer to the question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsOutput = z.infer<typeof AnswerVulnerabilityQuestionsOutputSchema>;

// In-memory cache for the Medtronic GPT token
const tokenCache = {
  apiToken: process.env.MEDTRONIC_GPT_API_TOKEN || null,
  expiresAt: 0, // A value of 0 forces a refresh on the first call
};

/**
 * Refreshes the Medtronic GPT API token.
 * This function is called when the current token is missing or expired.
 */
async function refreshMedtronicGptToken(): Promise<string> {
  console.log('Attempting to refresh Medtronic GPT API token...');
  
  const REFRESH_URL = process.env.MEDTRONIC_GPT_REFRESH_URL;
  const SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;
  const REFRESH_TOKEN = process.env.MEDTRONIC_GPT_REFRESH_TOKEN;
  const currentApiToken = tokenCache.apiToken; // Use the possibly expired token for the refresh call

  if (!REFRESH_URL || !SUBSCRIPTION_KEY || !REFRESH_TOKEN || !currentApiToken) {
    throw new Error('Missing Medtronic GPT refresh credentials. Please set MEDTRONIC_GPT_REFRESH_URL, MEDTRONIC_GPT_SUBSCRIPTION_KEY, MEDTRONIC_GPT_REFRESH_TOKEN, and an initial MEDTRONIC_GPT_API_TOKEN in your .env file.');
  }
  
  try {
    const response = await fetch(REFRESH_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': SUBSCRIPTION_KEY,
        'api-token': currentApiToken,
        'refresh-token': REFRESH_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Error refreshing Medtronic GPT token:', errorText);
      tokenCache.apiToken = null;
      tokenCache.expiresAt = 0;
      throw new Error(`Failed to refresh token: HTTP status ${response.status}. ${errorText}`);
    }
    
    const data = await response.json();
    const newApiToken = data.apiToken || data.token;
    
    if (!newApiToken) {
        throw new Error("New API token not found in the refresh response payload.");
    }
    
    tokenCache.apiToken = newApiToken;
    // Set expiry to 3600 seconds (1 hour) from now, with a 60-second buffer
    tokenCache.expiresAt = Date.now() + (3600 - 60) * 1000;
    
    console.log('Successfully refreshed Medtronic GPT API token.');
    return newApiToken;
  } catch (error) {
    console.error('A critical error occurred during token refresh:', error);
    tokenCache.apiToken = null;
    tokenCache.expiresAt = 0;
    throw error;
  }
}

/**
 * Retrieves a valid Medtronic GPT API token, refreshing it if necessary.
 */
async function getValidMedtronicGptToken(): Promise<string> {
  const isTokenExpired = Date.now() >= tokenCache.expiresAt;
  
  if (tokenCache.apiToken && !isTokenExpired) {
    return tokenCache.apiToken;
  }
  
  return await refreshMedtronicGptToken();
}

// New, more specific tool definitions
const tools = [
  {
    type: 'function',
    function: {
      name: 'get_findings',
      description: "Get vulnerability findings from DefectDojo. Can be filtered by product name, severity, and status. For example, to find the top 10 active, critical vulnerabilities in 'WebApp', set productName='WebApp', severity='Critical', active=true, and limit=10.",
      parameters: {
        type: 'object',
        properties: {
          productName: {
            type: 'string',
            description: "The name of the product to filter findings by. This must be an exact match.",
          },
          severity: {
            type: 'string',
            description: "The severity level to filter by (e.g., 'Critical', 'High').",
          },
          active: {
              type: 'boolean',
              description: 'Filter by active or inactive findings. Defaults to active if not specified.'
          },
          limit: {
              type: 'number',
              description: 'The maximum number of findings to return. Defaults to 10.'
          }
        },
        required: [], // All params are optional
      },
    },
  },
  {
    type: 'function',
    function: {
        name: 'get_product_list',
        description: 'Get a list of all product names available in DefectDojo. Use this when the user asks for "all products" or to list the products.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
    {
    type: 'function',
    function: {
        name: 'get_engagement_list',
        description: 'Get a list of all engagement names from DefectDojo. Use this when the user asks for "all engagements" or "all tools".',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_vulnerability_count_by_severity',
        description: 'Get a breakdown of active vulnerability counts by severity for a specific product. Use this when asked for counts, totals, or distribution of vulnerabilities for a product.',
        parameters: {
            type: 'object',
            properties: {
                productName: {
                    type: 'string',
                    description: 'The name of the product to get vulnerability counts for.'
                }
            },
            required: ['productName']
        }
    }
  }
];


export async function answerVulnerabilityQuestions(input: AnswerVulnerabilityQuestionsInput): Promise<AnswerVulnerabilityQuestionsOutput> {
  const MEDTRONIC_GPT_API_URL = process.env.MEDTRONIC_GPT_API_URL;
  const MEDTRONIC_GPT_SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;

  if (!MEDTRONIC_GPT_API_URL || !MEDTRONIC_GPT_SUBSCRIPTION_KEY) {
    return {
      answer: "Error: Medtronic GPT API credentials are not configured. Please set the MEDTRONIC_GPT_API_URL and MEDTRONIC_GPT_SUBSCRIPTION_KEY environment variables in your .env file."
    };
  }
  
  try {
    const validApiToken = await getValidMedtronicGptToken();

    const messages: any[] = [
        {
          role: 'system',
          content: "You are DojoGPT, a helpful assistant for vulnerability management. You MUST use the available tools to answer user questions about DefectDojo data. To list all products, use `get_product_list`. To list all engagements, use `get_engagement_list`. To find vulnerabilities, use the `get_findings` tool; you can filter by `productName`, `severity`, and `active` status. To get vulnerability counts and severity distribution for a product, use `get_vulnerability_count_by_severity`. Be precise with product names in your queries. Do not invent data. If a tool returns an error or no data, inform the user clearly.",
        },
        {
          role: 'user',
          content: input.question,
        },
    ];

    const requestBody = {
      messages,
      tools,
      tool_choice: 'auto',
    };

    const response = await fetch(MEDTRONIC_GPT_API_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
        'api-token': validApiToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Error from Medtronic GPT API:', errorText);
      if (response.status === 401) {
          tokenCache.expiresAt = 0; // Force a token refresh on the next attempt
          return {
              answer: `Authentication error with Medtronic GPT (HTTP 401). The API token might be invalid. A refresh will be attempted on the next request. Details: ${errorText}`
          };
      }
      return {
          answer: `Error calling Medtronic GPT: HTTP status ${response.status}. ${errorText}`
      };
    }

    const data = await response.json();
    const responseMessage = data.choices && data.choices[0] && data.choices[0].message;

    // Check if the model wants to call a tool
    if (responseMessage && responseMessage.tool_calls) {
        console.log(`Medtronic GPT wants to call ${responseMessage.tool_calls.length} tool(s).`);
        
        messages.push(responseMessage);
        
        for (const toolCall of responseMessage.tool_calls) {
            const functionName = toolCall.function.name;
            const args = JSON.parse(toolCall.function.arguments);
            let toolResponseContent = '';

            console.log(`Executing tool: ${functionName} with args:`, args);

            try {
                 switch (functionName) {
                    case 'get_findings':
                        const findingArgs = {
                            productName: args.productName,
                            severity: args.severity,
                            active: args.active !== undefined ? args.active : true, // Default to active
                            limit: args.limit || 10 // Default to 10
                        };
                        toolResponseContent = await getFindings(findingArgs);
                        break;
                    case 'get_product_list':
                        const products = await getProductList();
                        toolResponseContent = JSON.stringify(products);
                        break;
                    case 'get_engagement_list':
                        const engagements = await getEngagementList();
                        toolResponseContent = JSON.stringify(engagements);
                        break;
                    case 'get_vulnerability_count_by_severity':
                        const counts = await getVulnerabilityCountBySeverity(args.productName);
                        toolResponseContent = JSON.stringify(counts);
                        break;
                    default:
                        console.warn(`Unknown tool called: ${functionName}`);
                        toolResponseContent = JSON.stringify({ error: `The tool '${functionName}' is not recognized.` });
                }
            } catch (e) {
                const error = e instanceof Error ? e.message : String(e);
                console.error(`Error executing tool ${functionName}:`, error);
                toolResponseContent = JSON.stringify({ error: `An error occurred while running the tool: ${error}` });
            }

            messages.push({
                tool_call_id: toolCall.id,
                role: 'tool',
                name: functionName,
                content: toolResponseContent,
            });
        }
            
            console.log('Sending tool response back to Medtronic GPT.');
            const secondRequestBody = { messages, tools, tool_choice: 'auto' };
            const secondResponse = await fetch(MEDTRONIC_GPT_API_URL, {
                method: 'POST',
                headers: {
                    'api-version': '3.0',
                    'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
                    'api-token': validApiToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(secondRequestBody),
            });
            
            if (!secondResponse.ok) {
              const errorText = await secondResponse.text();
              return { answer: `Error processing tool result: HTTP status ${secondResponse.status}. ${errorText}` };
            }
            
            const secondData = await secondResponse.json();
            const finalAnswer = secondData.choices && secondData.choices[0] && secondData.choices[0].message && secondData.choices[0].message.content
                ? secondData.choices[0].message.content
                : "I couldn't process the data from DefectDojo.";

            return { answer: finalAnswer };
    }


    const answer = responseMessage && responseMessage.content
      ? responseMessage.content
      : "I'm sorry, I received an unexpected response from Medtronic GPT.";

    return { answer };
  } catch (error) {
    console.error('Error calling Medtronic GPT or refreshing token:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      answer: `There was a problem processing your request. Please check your configuration. Details: ${errorMessage}`
    };
  }
}
