
'use server';
/**
 * @fileOverview A vulnerability management chatbot that uses the Medtronic GPT and can query DefectDojo.
 *
 * - answerVulnerabilityQuestions - A function that answers questions using Medtronic GPT, with the ability to call tools.
 * - AnswerVulnerabilityQuestionsInput - The input type for the answerVulnerabilityQuestions function.
 * - AnswerVulnerabilityQuestionsOutput - The return type for the answerVulnerabilityQuestionsOutput function.
 */

import {z} from 'genkit';
import { getFindings, analyzeVulnerabilityData } from '@/services/defectdojo';


const AnswerVulnerabilityQuestionsInputSchema = z.object({
  question: z.string().describe('The question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsInput = z.infer<typeof AnswerVulnerabilityQuestionsInputSchema>;

const AnswerVulnerabilityQuestionsOutputSchema = z.object({
  answer: z.string().describe('The answer to the question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsOutput = z.infer<typeof AnswerVulnerabilityQuestionsOutputSchema>;

// In-memory cache for the Medtronic GPT token
const tokenCache = {
  apiToken: process.env.MEDTRONIC_GPT_API_TOKEN || null,
  expiresAt: 0, // A value of 0 forces a refresh on the first call
};

/**
 * Refreshes the Medtronic GPT API token.
 * This function is called when the current token is missing or expired.
 */
async function refreshMedtronicGptToken(): Promise<string> {
  const REFRESH_URL = process.env.MEDTRONIC_GPT_REFRESH_URL;
  const SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;
  const REFRESH_TOKEN = process.env.MEDTRONIC_GPT_REFRESH_TOKEN;
  const currentApiToken = tokenCache.apiToken; // Use the possibly expired token for the refresh call

  if (!REFRESH_URL || !SUBSCRIPTION_KEY || !REFRESH_TOKEN || !currentApiToken) {
    throw new Error('Missing Medtronic GPT refresh credentials. Please set MEDTRONIC_GPT_REFRESH_URL, MEDTRONIC_GPT_SUBSCRIPTION_KEY, MEDTRONIC_GPT_REFRESH_TOKEN, and an initial MEDTRONIC_GPT_API_TOKEN in your .env file.');
  }
  
  try {
    const response = await fetch(REFRESH_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': SUBSCRIPTION_KEY,
        'api-token': currentApiToken,
        'refresh-token': REFRESH_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      const errorText = await response.text();
      tokenCache.apiToken = null;
      tokenCache.expiresAt = 0;
      throw new Error(`Failed to refresh token: HTTP status ${response.status}. ${errorText}`);
    }
    
    const data = await response.json();
    const newApiToken = data.apiToken || data.token;
    
    if (!newApiToken) {
        throw new Error("New API token not found in the refresh response payload.");
    }
    
    tokenCache.apiToken = newApiToken;
    // Set expiry to 3600 seconds (1 hour) from now, with a 60-second buffer
    tokenCache.expiresAt = Date.now() + (3600 - 60) * 1000;
    
    return newApiToken;
  } catch (error) {
    tokenCache.apiToken = null;
    tokenCache.expiresAt = 0;
    throw error;
  }
}

/**
 * Retrieves a valid Medtronic GPT API token, refreshing it if necessary.
 */
async function getValidMedtronicGptToken(): Promise<string> {
  const isTokenExpired = Date.now() >= tokenCache.expiresAt;
  
  if (tokenCache.apiToken && !isTokenExpired) {
    return tokenCache.apiToken;
  }
  
  return await refreshMedtronicGptToken();
}

const tools = [
  {
    type: 'function',
    function: {
      name: 'get_findings',
      description: "Get a list of vulnerability findings from DefectDojo. Can be filtered by `productName`, `toolName`, `severity`, and `limit`. Use this for general queries about what vulnerabilities exist.",
      parameters: {
        type: 'object',
        properties: {
          productName: { type: 'string', description: "(Optional) The name of a single product to filter by." },
          severity: { type: 'string', description: "(Optional) The severity level (e.g., 'Critical', 'High')." },
          limit: { type: 'number', description: 'The maximum number of findings to return. Defaults to 10.' },
          toolName: { type: 'string', description: "(Optional) The name of the tool/scanner to filter by." },
        },
        required: [],
      },
    },
  },
  {
      type: 'function',
      function: {
          name: 'analyze_vulnerability_data',
          description: 'Performs advanced analysis on vulnerability data. Use this for complex questions about ranking components by risk, comparing tools, or identifying trends. This tool is for analysis, not for listing raw vulnerabilities.',
          parameters: {
              type: 'object',
              properties: {
                  productName: { type: 'string', description: "(Optional) The name of a single product to focus the analysis on. If omitted, the analysis will cover ALL products." },
                  analysisType: {
                      type: 'string',
                      description: 'The type of analysis to perform.',
                      enum: [
                          'component_risk', // For questions like "Which component should I fix first?" or "Which component has the most critical vulnerabilities?"
                          'tool_comparison', // For "Compare tool X and tool Y" or "Which tool finds more issues?"
                          'vulnerability_age', // For "Which is the oldest vulnerability?"
                          'cross_product_component_usage', // For "Which component is shared and vulnerable across products X and Y?"
                      ]
                  },
                  severities: {
                      type: 'array',
                      items: { type: 'string' },
                      description: "A list of severities to include in the analysis (e.g., ['Critical', 'High'])."
                  },
                  limit: { type: 'number', description: 'The number of results to return (e.g., top 5 components). Default is 5.' }
              },
              required: ['analysisType'],
          },
      },
  },
];


export async function answerVulnerabilityQuestions(input: AnswerVulnerabilityQuestionsInput): Promise<AnswerVulnerabilityQuestionsOutput> {
  const MEDTRONIC_GPT_API_URL = process.env.MEDTRONIC_GPT_API_URL;
  const MEDTRONIC_GPT_SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;

  if (!MEDTRONIC_GPT_API_URL || !MEDTRONIC_GPT_SUBSCRIPTION_KEY) {
    return {
      answer: "Error: Medtronic GPT API credentials are not configured. Please set the MEDTRONIC_GPT_API_URL and MEDTRONIC_GPT_SUBSCRIPTION_KEY environment variables in your .env file."
    };
  }
  
  try {
    const validApiToken = await getValidMedtronicGptToken();

    const messages: any[] = [
        {
          role: 'system',
          content: `You are DojoGPT, an expert vulnerability management assistant. Your primary goal is to help security teams **prioritize vulnerabilities and reduce risk** by providing clear, actionable summaries and mitigation strategies.

**Core Task & Tool Usage:**
- **For simple listing questions** (e.g., "List critical vulnerabilities for MCLS"): Use the \`get_findings\` tool.
- **For complex analytical questions** (e.g., "Which component is riskiest?", "Compare tools", "Which vuln is oldest?"): Use the powerful \`analyze_vulnerability_data\` tool. Choose the correct \`analysisType\` based on the user's question. For example:
    - "Which component in MCLS should be fixed first?" -> \`analysisType: 'component_risk', productName: 'MCLS'\`
    - "Which vulnerability in Carelink Network is the oldest?" -> \`analysisType: 'vulnerability_age', productName: 'Carelink Network'\`
    - "Compare Jfrog and DependencyTrack in MyCareLink Patient Monitor" -> \`analysisType: 'tool_comparison', productName: 'MyCareLink Patient Monitor'\`
    - "Which vulnerable component is shared between CLEM and MCLH?" -> \`analysisType: 'cross_product_component_usage', productName: 'CLEM,MCLH'\`
    - "Which library across all products is most critical?" -> \`analysisType: 'component_risk'\` (no productName)
- When you get data back, analyze it and present a clear summary. Don't just list the raw data. 
- **Prioritize findings based on severity and potential impact (CVSS score).**

**Formatting Rules (Strictly Follow):**
- Use Markdown.
- Use **bold text** for headings. DO NOT use Markdown headers ('#', '##').
- Use numbered lists for main findings and bullet points for details.

**Response Structure:**
1.  **Introduction**: Start with a friendly confirmation and state what you found (e.g., "Certainly! I analyzed the components in product Y and found that 'openssl' presents the highest risk. Here's the breakdown:").
2.  **Findings Summary**: A bold heading like '**Analysis Summary**'.
3.  **Result List**: A numbered list of the results. Each item should be a bold component name or finding title. Use sub-bullets for details like 'Reason', 'Critical Count', 'High Count', 'Oldest Vulnerability Date'.
4.  **Prioritized Action Plan**: A bold heading like '**Recommendation**' or '**Prioritized Action Plan**'.
5.  **Action List**: A bulleted list of clear, prioritized remediation steps. **If mitigation steps are not provided in the data, you MUST generate detailed, expert-level remediation advice based on the vulnerability's title, CWE, and type.**
6.  **Closing**: End with a helpful closing remark.`,
        },
        {
          role: 'user',
          content: input.question,
        },
    ];

    const requestBody = {
      messages,
      tools,
      tool_choice: 'auto',
    };

    const response = await fetch(MEDTRONIC_GPT_API_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
        'api-token': validApiToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      if (response.status === 401) {
          tokenCache.expiresAt = 0; // Force a token refresh on the next attempt
          return {
              answer: `Authentication error with Medtronic GPT (HTTP 401). The API token might be invalid. A refresh will be attempted on the next request. Details: ${errorText}`
          };
      }
      return {
          answer: `Error calling Medtronic GPT: HTTP status ${response.status}. ${errorText}`
      };
    }

    const data = await response.json();
    const responseMessage = data.choices && data.choices[0] && data.choices[0].message;

    // Check if the model wants to call a tool
    if (responseMessage && responseMessage.tool_calls) {
        messages.push(responseMessage);
        
        for (const toolCall of responseMessage.tool_calls) {
            const functionName = toolCall.function.name;
            const args = JSON.parse(toolCall.function.arguments);
            let toolResponseContent = '';


            try {
                 switch (functionName) {
                    case 'get_findings':
                        toolResponseContent = await getFindings(args.productName, args.severity, true, args.limit, args.toolName);
                        break;
                    case 'analyze_vulnerability_data':
                        const analysisResult = await analyzeVulnerabilityData(args.analysisType, args.productName, args.severities, args.limit);
                        toolResponseContent = JSON.stringify(analysisResult);
                        break;
                    default:
                        toolResponseContent = JSON.stringify({ error: `The tool '${functionName}' is not recognized.` });
                }
            } catch (e) {
                const error = e instanceof Error ? e.message : String(e);
                toolResponseContent = JSON.stringify({ error: `An error occurred while running the tool: ${error}` });
            }

            messages.push({
                tool_call_id: toolCall.id,
                role: 'tool',
                name: functionName,
                content: toolResponseContent,
            });
        }
            
            const secondRequestBody = { messages, tools, tool_choice: 'auto' };
            const secondResponse = await fetch(MEDTRONIC_GPT_API_URL, {
                method: 'POST',
                headers: {
                    'api-version': '3.0',
                    'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
                    'api-token': validApiToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(secondRequestBody),
            });
            
            if (!secondResponse.ok) {
              const errorText = await secondResponse.text();
              return { answer: `Error processing tool result: HTTP status ${secondResponse.status}. ${errorText}` };
            }
            
            const secondData = await secondResponse.json();
            const finalAnswer = secondData.choices && secondData.choices[0] && secondData.choices[0].message && secondData.choices[0].message.content
                ? secondData.choices[0].message.content
                : "I couldn't process the data from DefectDojo.";

            return { answer: finalAnswer };
    }


    const answer = responseMessage && responseMessage.content
      ? responseMessage.content
      : "I'm sorry, I received an unexpected response from Medtronic GPT.";

    return { answer };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      answer: `There was a problem processing your request. Please check your configuration. Details: ${errorMessage}`
    };
  }
}
