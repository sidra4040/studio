
'use server';
/**
 * @fileOverview A vulnerability management chatbot that uses the Medtronic GPT and can query DefectDojo.
 *
 * - answerVulnerabilityQuestions - A function that answers questions using Medtronic GPT, with the ability to call tools.
 * - AnswerVulnerabilityQuestionsInput - The input type for the answerVulnerabilityQuestions function.
 * - AnswerVulnerabilityQuestionsOutput - The return type for the answerVulnerabilityQuestions function.
 */

import {z} from 'genkit';
import { getFindings, getProductList, getVulnerabilityCountBySeverity, getTotalFindingCount, getProductVulnerabilitySummary, getToolList, getTopCriticalVulnerabilityPerProduct } from '@/services/defectdojo';


const AnswerVulnerabilityQuestionsInputSchema = z.object({
  question: z.string().describe('The question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsInput = z.infer<typeof AnswerVulnerabilityQuestionsInputSchema>;

const AnswerVulnerabilityQuestionsOutputSchema = z.object({
  answer: z.string().describe('The answer to the question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsOutput = z.infer<typeof AnswerVulnerabilityQuestionsOutputSchema>;

// In-memory cache for the Medtronic GPT token
const tokenCache = {
  apiToken: process.env.MEDTRONIC_GPT_API_TOKEN || null,
  expiresAt: 0, // A value of 0 forces a refresh on the first call
};

/**
 * Refreshes the Medtronic GPT API token.
 * This function is called when the current token is missing or expired.
 */
async function refreshMedtronicGptToken(): Promise<string> {
  console.log('Attempting to refresh Medtronic GPT API token...');
  
  const REFRESH_URL = process.env.MEDTRONIC_GPT_REFRESH_URL;
  const SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;
  const REFRESH_TOKEN = process.env.MEDTRONIC_GPT_REFRESH_TOKEN;
  const currentApiToken = tokenCache.apiToken; // Use the possibly expired token for the refresh call

  if (!REFRESH_URL || !SUBSCRIPTION_KEY || !REFRESH_TOKEN || !currentApiToken) {
    throw new Error('Missing Medtronic GPT refresh credentials. Please set MEDTRONIC_GPT_REFRESH_URL, MEDTRONIC_GPT_SUBSCRIPTION_KEY, MEDTRONIC_GPT_REFRESH_TOKEN, and an initial MEDTRONIC_GPT_API_TOKEN in your .env file.');
  }
  
  try {
    const response = await fetch(REFRESH_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': SUBSCRIPTION_KEY,
        'api-token': currentApiToken,
        'refresh-token': REFRESH_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Error refreshing Medtronic GPT token:', errorText);
      tokenCache.apiToken = null;
      tokenCache.expiresAt = 0;
      throw new Error(`Failed to refresh token: HTTP status ${response.status}. ${errorText}`);
    }
    
    const data = await response.json();
    const newApiToken = data.apiToken || data.token;
    
    if (!newApiToken) {
        throw new Error("New API token not found in the refresh response payload.");
    }
    
    tokenCache.apiToken = newApiToken;
    // Set expiry to 3600 seconds (1 hour) from now, with a 60-second buffer
    tokenCache.expiresAt = Date.now() + (3600 - 60) * 1000;
    
    console.log('Successfully refreshed Medtronic GPT API token.');
    return newApiToken;
  } catch (error) {
    console.error('A critical error occurred during token refresh:', error);
    tokenCache.apiToken = null;
    tokenCache.expiresAt = 0;
    throw error;
  }
}

/**
 * Retrieves a valid Medtronic GPT API token, refreshing it if necessary.
 */
async function getValidMedtronicGptToken(): Promise<string> {
  const isTokenExpired = Date.now() >= tokenCache.expiresAt;
  
  if (tokenCache.apiToken && !isTokenExpired) {
    return tokenCache.apiToken;
  }
  
  return await refreshMedtronicGptToken();
}

// New, more specific tool definitions
const tools = [
  {
    type: 'function',
    function: {
      name: 'get_findings',
      description: "Get vulnerability findings from DefectDojo. Can be filtered by `productName`, `toolName`, or both. A `productName` is NOT required if a `toolName` is provided, and vice-versa. For example, to find all critical vulnerabilities from the 'Rapid7' scanner, call this tool with `toolName: 'Rapid7'`. To find vulnerabilities for the 'WebApp' product, call with `productName: 'WebApp'`. You can also combine them to find vulnerabilities for a specific product from a specific tool.",
      parameters: {
        type: 'object',
        properties: {
          productName: {
            type: 'string',
            description: "(Optional) The name of the product (e.g., 'CLEM', 'MCLS') to filter findings by. Use this for product-specific queries.",
          },
          severity: {
            type: 'string',
            description: "The severity level to filter by (e.g., 'Critical', 'High').",
          },
          active: {
              type: 'boolean',
              description: 'Filter by active or inactive findings. Defaults to active if not specified.'
          },
          limit: {
              type: 'number',
              description: 'The maximum number of findings to return. Defaults to 10.'
          },
          toolName: {
            type: 'string',
            description: "(Optional) The name of the tool/scanner (e.g., 'Rapid7', 'Sonarqube', 'CloudGuard') to filter findings by. Use this for tool-specific queries.",
          },
        },
        required: [], // All params are optional
      },
    },
  },
  {
    type: 'function',
    function: {
        name: 'get_product_list',
        description: 'Get a list of all product names available in DefectDojo. Use this when the user asks for "all products" or to list the products.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_tool_list',
        description: 'Get a list of all tool/scanner names (Test Types) from DefectDojo. Use this when the user asks to "list all tools" or to see available scanners.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_vulnerability_count_by_severity',
        description: 'Get a breakdown of active vulnerability counts by severity for a specific product. Use this when asked for counts, totals, or distribution of vulnerabilities for a product.',
        parameters: {
            type: 'object',
            properties: {
                productName: {
                    type: 'string',
                    description: 'The name of the product to get vulnerability counts for.'
                }
            },
            required: ['productName']
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_total_findings_count',
        description: 'Get the total number of all findings (vulnerabilities) in the system. Use this when asked for "total findings" or "how many findings".',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_product_vulnerability_summary',
        description: 'Get a summary of vulnerability counts (Critical, High, etc.) for all products. Use this to determine which product has the most vulnerabilities of a certain severity.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_top_critical_vulnerability_per_product',
        description: 'Get the single most critical vulnerability for each product in the system. Use this when the user asks for a summary or one example vulnerability from every product.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  }
];


export async function answerVulnerabilityQuestions(input: AnswerVulnerabilityQuestionsInput): Promise<AnswerVulnerabilityQuestionsOutput> {
  const MEDTRONIC_GPT_API_URL = process.env.MEDTRONIC_GPT_API_URL;
  const MEDTRONIC_GPT_SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;

  if (!MEDTRONIC_GPT_API_URL || !MEDTRONIC_GPT_SUBSCRIPTION_KEY) {
    return {
      answer: "Error: Medtronic GPT API credentials are not configured. Please set the MEDTRONIC_GPT_API_URL and MEDTRONIC_GPT_SUBSCRIPTION_KEY environment variables in your .env file."
    };
  }
  
  try {
    const validApiToken = await getValidMedtronicGptToken();

    const messages: any[] = [
        {
          role: 'system',
          content: `You are DojoGPT, an expert vulnerability management assistant. Your goal is to provide clear, actionable summaries of vulnerability data from DefectDojo.

**Core Task:**
- Analyze user queries to see if they are about a 'product' (e.g., 'CLEM') or a 'tool' (e.g., 'Rapid7', 'Sonarqube'). Use the correct tool parameters for the search.
- When you get vulnerability data back, analyze it and present a clear summary. Don't just list the raw data. Group related findings where possible (e.g., multiple CVEs for one component).

**Formatting Rules (Strictly Follow):**
- Use Markdown.
- Use **bold text** for headings. DO NOT use Markdown headers ('#', '##').
- Use numbered lists for main findings and bullet points for details.

**Response Structure:**
1.  **Introduction**: Start with a friendly confirmation and state what you found (e.g., "Certainly! I found X critical findings for product Y. Here is a summary:").
2.  **Findings Summary**: A bold heading like '**Critical Findings Summary**'.
3.  **Vulnerability List**: A numbered list. Each item should be a bold component name or finding title. Use sub-bullets for details like 'Finding ID', 'Issue', 'CVSS', 'Impact', 'CWE'.
4.  **Actions Required**: A bold heading like '**Immediate Actions Required**'.
5.  **Action List**: A bulleted list of clear remediation steps. **If mitigation steps are not provided in the data, you MUST generate appropriate remediation advice based on the vulnerability's title and type.**
6.  **Closing**: End with a helpful closing remark (e.g., "Would you like me to provide further details?").

**Example Response:**

Certainly! I found 40 critical findings for CLEM. Here's a summary of the top 5:

**Critical Findings Summary**

1.  **libpng Component**
    - **Finding ID**: 1928
    - **Issue**: Improper chunk length checks in libpng before version 1.6.32.
    - **CVSS**: 9.8

2.  **libxml2 Component (Grouped)**
    - **Finding ID**: 1940 - CVE-2017-7376 (Buffer overflow) - **CVSS**: 9.8
    - **Finding ID**: 1941 - CVE-2016-4658 (Use-after-free) - **CVSS**: 9.8

**Immediate Actions Required**
- Upgrade **libpng** to version 1.6.32 or later.
- Upgrade **libxml2** to version 2.9.5 or later.

Would you like more details on any of these items?`,
        },
        {
          role: 'user',
          content: input.question,
        },
    ];

    const requestBody = {
      messages,
      tools,
      tool_choice: 'auto',
    };

    const response = await fetch(MEDTRONIC_GPT_API_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
        'api-token': validApiToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Error from Medtronic GPT API:', errorText);
      if (response.status === 401) {
          tokenCache.expiresAt = 0; // Force a token refresh on the next attempt
          return {
              answer: `Authentication error with Medtronic GPT (HTTP 401). The API token might be invalid. A refresh will be attempted on the next request. Details: ${errorText}`
          };
      }
      return {
          answer: `Error calling Medtronic GPT: HTTP status ${response.status}. ${errorText}`
      };
    }

    const data = await response.json();
    const responseMessage = data.choices && data.choices[0] && data.choices[0].message;

    // Check if the model wants to call a tool
    if (responseMessage && responseMessage.tool_calls) {
        console.log(`Medtronic GPT wants to call ${responseMessage.tool_calls.length} tool(s).`);
        
        messages.push(responseMessage);
        
        for (const toolCall of responseMessage.tool_calls) {
            const functionName = toolCall.function.name;
            const args = JSON.parse(toolCall.function.arguments);
            let toolResponseContent = '';

            console.log(`Executing tool: ${functionName} with args:`, args);

            try {
                 switch (functionName) {
                    case 'get_findings':
                        const findingArgs = {
                            productName: args.productName,
                            severity: args.severity,
                            active: args.active !== undefined ? args.active : true, // Default to active
                            limit: args.limit || 10, // Default to 10
                            toolName: args.toolName,
                        };
                        toolResponseContent = await getFindings(findingArgs);
                        break;
                    case 'get_product_list':
                        const products = await getProductList();
                        toolResponseContent = JSON.stringify(products);
                        break;
                    case 'get_tool_list':
                        const tools = await getToolList();
                        toolResponseContent = JSON.stringify(tools);
                        break;
                    case 'get_vulnerability_count_by_severity':
                        const counts = await getVulnerabilityCountBySeverity(args.productName);
                        toolResponseContent = JSON.stringify(counts);
                        break;
                    case 'get_total_findings_count':
                        const totalCount = await getTotalFindingCount();
                        toolResponseContent = JSON.stringify(totalCount);
                        break;
                    case 'get_product_vulnerability_summary':
                        const summary = await getProductVulnerabilitySummary();
                        toolResponseContent = JSON.stringify(summary);
                        break;
                    case 'get_top_critical_vulnerability_per_product':
                        toolResponseContent = await getTopCriticalVulnerabilityPerProduct();
                        break;
                    default:
                        console.warn(`Unknown tool called: ${functionName}`);
                        toolResponseContent = JSON.stringify({ error: `The tool '${functionName}' is not recognized.` });
                }
            } catch (e) {
                const error = e instanceof Error ? e.message : String(e);
                console.error(`Error executing tool ${functionName}:`, error);
                toolResponseContent = JSON.stringify({ error: `An error occurred while running the tool: ${error}` });
            }

            messages.push({
                tool_call_id: toolCall.id,
                role: 'tool',
                name: functionName,
                content: toolResponseContent,
            });
        }
            
            console.log('Sending tool response back to Medtronic GPT.');
            const secondRequestBody = { messages, tools, tool_choice: 'auto' };
            const secondResponse = await fetch(MEDTRONIC_GPT_API_URL, {
                method: 'POST',
                headers: {
                    'api-version': '3.0',
                    'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
                    'api-token': validApiToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(secondRequestBody),
            });
            
            if (!secondResponse.ok) {
              const errorText = await secondResponse.text();
              return { answer: `Error processing tool result: HTTP status ${secondResponse.status}. ${errorText}` };
            }
            
            const secondData = await secondResponse.json();
            const finalAnswer = secondData.choices && secondData.choices[0] && secondData.choices[0].message && secondData.choices[0].message.content
                ? secondData.choices[0].message.content
                : "I couldn't process the data from DefectDojo.";

            return { answer: finalAnswer };
    }


    const answer = responseMessage && responseMessage.content
      ? responseMessage.content
      : "I'm sorry, I received an unexpected response from Medtronic GPT.";

    return { answer };
  } catch (error) {
    console.error('Error calling Medtronic GPT or refreshing token:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      answer: `There was a problem processing your request. Please check your configuration. Details: ${errorMessage}`
    };
  }
}
