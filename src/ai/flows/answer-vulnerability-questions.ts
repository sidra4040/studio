'use server';
/**
 * @fileOverview A vulnerability management chatbot that uses the Medtronic GPT and can query DefectDojo.
 *
 * - answerVulnerabilityQuestions - A function that answers questions using Medtronic GPT, with the ability to call tools.
 * - AnswerVulnerabilityQuestionsInput - The input type for the answerVulnerabilityQuestions function.
 * - AnswerVulnerabilityQuestionsOutput - The return type for the answerVulnerabilityQuestions function.
 */

import {z} from 'genkit';
import { getFindings, getProductList, getVulnerabilityCountBySeverity, getEngagementList, getTotalFindingCount, getProductVulnerabilitySummary } from '@/services/defectdojo';


const AnswerVulnerabilityQuestionsInputSchema = z.object({
  question: z.string().describe('The question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsInput = z.infer<typeof AnswerVulnerabilityQuestionsInputSchema>;

const AnswerVulnerabilityQuestionsOutputSchema = z.object({
  answer: z.string().describe('The answer to the question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsOutput = z.infer<typeof AnswerVulnerabilityQuestionsOutputSchema>;

// In-memory cache for the Medtronic GPT token
const tokenCache = {
  apiToken: process.env.MEDTRONIC_GPT_API_TOKEN || null,
  expiresAt: 0, // A value of 0 forces a refresh on the first call
};

/**
 * Refreshes the Medtronic GPT API token.
 * This function is called when the current token is missing or expired.
 */
async function refreshMedtronicGptToken(): Promise<string> {
  console.log('Attempting to refresh Medtronic GPT API token...');
  
  const REFRESH_URL = process.env.MEDTRONIC_GPT_REFRESH_URL;
  const SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;
  const REFRESH_TOKEN = process.env.MEDTRONIC_GPT_REFRESH_TOKEN;
  const currentApiToken = tokenCache.apiToken; // Use the possibly expired token for the refresh call

  if (!REFRESH_URL || !SUBSCRIPTION_KEY || !REFRESH_TOKEN || !currentApiToken) {
    throw new Error('Missing Medtronic GPT refresh credentials. Please set MEDTRONIC_GPT_REFRESH_URL, MEDTRONIC_GPT_SUBSCRIPTION_KEY, MEDTRONIC_GPT_REFRESH_TOKEN, and an initial MEDTRONIC_GPT_API_TOKEN in your .env file.');
  }
  
  try {
    const response = await fetch(REFRESH_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': SUBSCRIPTION_KEY,
        'api-token': currentApiToken,
        'refresh-token': REFRESH_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Error refreshing Medtronic GPT token:', errorText);
      tokenCache.apiToken = null;
      tokenCache.expiresAt = 0;
      throw new Error(`Failed to refresh token: HTTP status ${response.status}. ${errorText}`);
    }
    
    const data = await response.json();
    const newApiToken = data.apiToken || data.token;
    
    if (!newApiToken) {
        throw new Error("New API token not found in the refresh response payload.");
    }
    
    tokenCache.apiToken = newApiToken;
    // Set expiry to 3600 seconds (1 hour) from now, with a 60-second buffer
    tokenCache.expiresAt = Date.now() + (3600 - 60) * 1000;
    
    console.log('Successfully refreshed Medtronic GPT API token.');
    return newApiToken;
  } catch (error) {
    console.error('A critical error occurred during token refresh:', error);
    tokenCache.apiToken = null;
    tokenCache.expiresAt = 0;
    throw error;
  }
}

/**
 * Retrieves a valid Medtronic GPT API token, refreshing it if necessary.
 */
async function getValidMedtronicGptToken(): Promise<string> {
  const isTokenExpired = Date.now() >= tokenCache.expiresAt;
  
  if (tokenCache.apiToken && !isTokenExpired) {
    return tokenCache.apiToken;
  }
  
  return await refreshMedtronicGptToken();
}

// New, more specific tool definitions
const tools = [
  {
    type: 'function',
    function: {
      name: 'get_findings',
      description: "Get vulnerability findings from DefectDojo. Can be filtered by product name, severity, status, and the tool/scanner name. For example, to find the top 10 active, critical vulnerabilities in 'WebApp' found by 'ZAP', set productName='WebApp', severity='Critical', active=true, limit=10, and toolName='ZAP'.",
      parameters: {
        type: 'object',
        properties: {
          productName: {
            type: 'string',
            description: "The name of the product to filter findings by. This must be an exact match.",
          },
          severity: {
            type: 'string',
            description: "The severity level to filter by (e.g., 'Critical', 'High').",
          },
          active: {
              type: 'boolean',
              description: 'Filter by active or inactive findings. Defaults to active if not specified.'
          },
          limit: {
              type: 'number',
              description: 'The maximum number of findings to return. Defaults to 10.'
          },
          toolName: {
            type: 'string',
            description: "The name of the tool/scanner to filter findings by (e.g., 'Rapid7', 'ZAP').",
          },
        },
        required: [], // All params are optional
      },
    },
  },
  {
    type: 'function',
    function: {
        name: 'get_product_list',
        description: 'Get a list of all product names available in DefectDojo. Use this when the user asks for "all products" or to list the products.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
    {
    type: 'function',
    function: {
        name: 'get_engagement_list',
        description: 'Get a list of all engagement names from DefectDojo. Use this when the user asks for "all engagements" or "all tools".',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_vulnerability_count_by_severity',
        description: 'Get a breakdown of active vulnerability counts by severity for a specific product. Use this when asked for counts, totals, or distribution of vulnerabilities for a product.',
        parameters: {
            type: 'object',
            properties: {
                productName: {
                    type: 'string',
                    description: 'The name of the product to get vulnerability counts for.'
                }
            },
            required: ['productName']
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_total_findings_count',
        description: 'Get the total number of all findings (vulnerabilities) in the system. Use this when asked for "total findings" or "how many findings".',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_product_vulnerability_summary',
        description: 'Get a summary of vulnerability counts (Critical, High, etc.) for all products. Use this to determine which product has the most vulnerabilities of a certain severity.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  }
];


export async function answerVulnerabilityQuestions(input: AnswerVulnerabilityQuestionsInput): Promise<AnswerVulnerabilityQuestionsOutput> {
  const MEDTRONIC_GPT_API_URL = process.env.MEDTRONIC_GPT_API_URL;
  const MEDTRONIC_GPT_SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;

  if (!MEDTRONIC_GPT_API_URL || !MEDTRONIC_GPT_SUBSCRIPTION_KEY) {
    return {
      answer: "Error: Medtronic GPT API credentials are not configured. Please set the MEDTRONIC_GPT_API_URL and MEDTRONIC_GPT_SUBSCRIPTION_KEY environment variables in your .env file."
    };
  }
  
  try {
    const validApiToken = await getValidMedtronicGptToken();

    const messages: any[] = [
        {
          role: 'system',
          content: `You are DojoGPT, an expert vulnerability management assistant. Your primary goal is to provide clear, conversational, and actionable summaries of vulnerability data from DefectDojo. You MUST strictly follow the formatting and persona rules below.

**Persona & Tone:**
- Start your response with a friendly, conversational sentence confirming what you're about to do (e.g., "Certainly, let me look up the high-severity findings for [Product Name]...").
- Be concise and get straight to the point.
- Your tone should be that of a helpful security analyst presenting a report.

**Response Formatting Rules (VERY IMPORTANT):**
- **NO MARKDOWN HEADERS:** Do not use '#', '##', '###', etc. Use **bold text** for headings instead.
- **NO HORIZONTAL RULES:** Do not use '---' or '***'.
- **Summarize First:** After the introduction, state the total number of findings you found. (e.g., "I found 8 critical findings for Patient Connector 24965.").
- **Analyze and Group:** This is crucial. Look for patterns in the findings. If multiple vulnerabilities affect the same component (e.g., "openssl", "linux_kernel"), group them together under a single heading. This provides a much clearer overview than a simple list.
- **Use Clear Headings:** Use bold headings like **Critical Findings Summary** and **Immediate Actions Required** to structure your report.
- **Present Findings Concisely:** For each finding or group, provide:
  - The Finding ID (e.g., \`(Finding ID: 13081)\`)
  - The CVE if available (e.g., \`CVE-2023-36328\`)
  - A brief, one-line summary of the issue.
  - The CVSS score if available.
- **Actionable Summary:** Conclude with a clear, high-level summary of what actions should be taken, as seen in the user's example.
- **Handle "No Results":** If a tool returns no findings, state that clearly and politely (e.g., "I searched for high-severity vulnerabilities in [Product Name] but didn't find any active ones.").

**Tool Usage Rules:**
- You MUST use the available tools to answer user questions. Do not invent data.
- \`get_findings\`: Use this to get a list of vulnerabilities. You can filter by \`productName\`, \`severity\`, \`active\` status, and \`toolName\`.
- \`get_product_list\`: To list all available products.
- \`get_engagement_list\`: To list all engagements/scanners.
- \`get_vulnerability_count_by_severity\`: For a breakdown of vulnerability counts for a specific product.
- \`get_product_vulnerability_summary\`: To find out which product has the most vulnerabilities of a certain type.
- \`get_total_findings_count\`: For the total number of findings in the entire system.`,
        },
        {
          role: 'user',
          content: input.question,
        },
    ];

    const requestBody = {
      messages,
      tools,
      tool_choice: 'auto',
    };

    const response = await fetch(MEDTRONIC_GPT_API_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
        'api-token': validApiToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Error from Medtronic GPT API:', errorText);
      if (response.status === 401) {
          tokenCache.expiresAt = 0; // Force a token refresh on the next attempt
          return {
              answer: `Authentication error with Medtronic GPT (HTTP 401). The API token might be invalid. A refresh will be attempted on the next request. Details: ${errorText}`
          };
      }
      return {
          answer: `Error calling Medtronic GPT: HTTP status ${response.status}. ${errorText}`
      };
    }

    const data = await response.json();
    const responseMessage = data.choices && data.choices[0] && data.choices[0].message;

    // Check if the model wants to call a tool
    if (responseMessage && responseMessage.tool_calls) {
        console.log(`Medtronic GPT wants to call ${responseMessage.tool_calls.length} tool(s).`);
        
        messages.push(responseMessage);
        
        for (const toolCall of responseMessage.tool_calls) {
            const functionName = toolCall.function.name;
            const args = JSON.parse(toolCall.function.arguments);
            let toolResponseContent = '';

            console.log(`Executing tool: ${functionName} with args:`, args);

            try {
                 switch (functionName) {
                    case 'get_findings':
                        const findingArgs = {
                            productName: args.productName,
                            severity: args.severity,
                            active: args.active !== undefined ? args.active : true, // Default to active
                            limit: args.limit || 10, // Default to 10
                            toolName: args.toolName,
                        };
                        toolResponseContent = await getFindings(findingArgs);
                        break;
                    case 'get_product_list':
                        const products = await getProductList();
                        toolResponseContent = JSON.stringify(products);
                        break;
                    case 'get_engagement_list':
                        const engagements = await getEngagementList();
                        toolResponseContent = JSON.stringify(engagements);
                        break;
                    case 'get_vulnerability_count_by_severity':
                        const counts = await getVulnerabilityCountBySeverity(args.productName);
                        toolResponseContent = JSON.stringify(counts);
                        break;
                    case 'get_total_findings_count':
                        const totalCount = await getTotalFindingCount();
                        toolResponseContent = JSON.stringify(totalCount);
                        break;
                    case 'get_product_vulnerability_summary':
                        const summary = await getProductVulnerabilitySummary();
                        toolResponseContent = JSON.stringify(summary);
                        break;
                    default:
                        console.warn(`Unknown tool called: ${functionName}`);
                        toolResponseContent = JSON.stringify({ error: `The tool '${functionName}' is not recognized.` });
                }
            } catch (e) {
                const error = e instanceof Error ? e.message : String(e);
                console.error(`Error executing tool ${functionName}:`, error);
                toolResponseContent = JSON.stringify({ error: `An error occurred while running the tool: ${error}` });
            }

            messages.push({
                tool_call_id: toolCall.id,
                role: 'tool',
                name: functionName,
                content: toolResponseContent,
            });
        }
            
            console.log('Sending tool response back to Medtronic GPT.');
            const secondRequestBody = { messages, tools, tool_choice: 'auto' };
            const secondResponse = await fetch(MEDTRONIC_GPT_API_URL, {
                method: 'POST',
                headers: {
                    'api-version': '3.0',
                    'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
                    'api-token': validApiToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(secondRequestBody),
            });
            
            if (!secondResponse.ok) {
              const errorText = await secondResponse.text();
              return { answer: `Error processing tool result: HTTP status ${secondResponse.status}. ${errorText}` };
            }
            
            const secondData = await secondResponse.json();
            const finalAnswer = secondData.choices && secondData.choices[0] && secondData.choices[0].message && secondData.choices[0].message.content
                ? secondData.choices[0].message.content
                : "I couldn't process the data from DefectDojo.";

            return { answer: finalAnswer };
    }


    const answer = responseMessage && responseMessage.content
      ? responseMessage.content
      : "I'm sorry, I received an unexpected response from Medtronic GPT.";

    return { answer };
  } catch (error) {
    console.error('Error calling Medtronic GPT or refreshing token:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      answer: `There was a problem processing your request. Please check your configuration. Details: ${errorMessage}`
    };
  }
}
