
'use server';
/**
 * @fileOverview A vulnerability management chatbot that uses the Medtronic GPT and can query DefectDojo.
 *
 * - answerVulnerabilityQuestions - A function that answers questions using Medtronic GPT, with the ability to call tools.
 * - AnswerVulnerabilityQuestionsInput - The input type for the answerVulnerabilityQuestions function.
 * - AnswerVulnerabilityQuestionsOutput - The return type for the answerVulnerabilityQuestionsOutput function.
 */

import {z} from 'genkit';
import { getFindings, analyzeVulnerabilityData } from '@/services/defectdojo';


const AnswerVulnerabilityQuestionsInputSchema = z.object({
  question: z.string().describe('The question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsInput = z.infer<typeof AnswerVulnerabilityQuestionsInputSchema>;

const AnswerVulnerabilityQuestionsOutputSchema = z.object({
  answer: z.string().describe('The answer to the question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsOutput = z.infer<typeof AnswerVulnerabilityQuestionsOutputSchema>;

// In-memory cache for the Medtronic GPT token
const tokenCache = {
  apiToken: process.env.MEDTRONIC_GPT_API_TOKEN || null,
  expiresAt: 0, // A value of 0 forces a refresh on the first call
};

/**
 * Refreshes the Medtronic GPT API token.
 * This function is called when the current token is missing or expired.
 */
async function refreshMedtronicGptToken(): Promise<string> {
  const REFRESH_URL = process.env.MEDTRONIC_GPT_REFRESH_URL;
  const SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;
  const REFRESH_TOKEN = process.env.MEDTRONIC_GPT_REFRESH_TOKEN;
  const currentApiToken = tokenCache.apiToken; // Use the possibly expired token for the refresh call

  if (!REFRESH_URL || !SUBSCRIPTION_KEY || !REFRESH_TOKEN || !currentApiToken) {
    throw new Error('Missing Medtronic GPT refresh credentials. Please set MEDTRONIC_GPT_REFRESH_URL, MEDTRONIC_GPT_SUBSCRIPTION_KEY, MEDTRONIC_GPT_REFRESH_TOKEN, and an initial MEDTRONIC_GPT_API_TOKEN in your .env file.');
  }
  
  try {
    const response = await fetch(REFRESH_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': SUBSCRIPTION_KEY,
        'api-token': currentApiToken,
        'refresh-token': REFRESH_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      const errorText = await response.text();
      tokenCache.apiToken = null;
      tokenCache.expiresAt = 0;
      throw new Error(`Failed to refresh token: HTTP status ${response.status}. ${errorText}`);
    }
    
    const data = await response.json();
    const newApiToken = data.apiToken || data.token;
    
    if (!newApiToken) {
        throw new Error("New API token not found in the refresh response payload.");
    }
    
    tokenCache.apiToken = newApiToken;
    // Set expiry to 3600 seconds (1 hour) from now, with a 60-second buffer
    tokenCache.expiresAt = Date.now() + (3600 - 60) * 1000;
    
    return newApiToken;
  } catch (error) {
    tokenCache.apiToken = null;
    tokenCache.expiresAt = 0;
    throw error;
  }
}

/**
 * Retrieves a valid Medtronic GPT API token, refreshing it if necessary.
 */
async function getValidMedtronicGptToken(): Promise<string> {
  const isTokenExpired = Date.now() >= tokenCache.expiresAt;
  
  if (tokenCache.apiToken && !isTokenExpired) {
    return tokenCache.apiToken;
  }
  
  return await refreshMedtronicGptToken();
}

const tools = [
  {
    type: 'function',
    function: {
      name: 'get_findings',
      description: "Get a list of vulnerability findings from DefectDojo. Use this for specific, direct questions that ask to 'list', 'show', 'find', 'count', or 'what is' something. This is your primary tool for retrieving raw data.",
      parameters: {
        type: 'object',
        properties: {
          productName: { type: 'string', description: "(Optional) The name of a single product to filter by (e.g., 'MCLS')." },
          toolName: { type: 'string', description: "(Optional) The name of the tool/scanner to filter by (e.g., 'DependencyTrack')." },
          severity: { type: 'string', description: "(Optional) The severity level to filter by (e.g., 'Critical', 'High')." },
          cve: { type: 'string', description: "(Optional) A specific CVE to search for." },
          componentName: { type: 'string', description: "(Optional) The name of a component/library to filter by (e.g., 'openssl')." },
          limit: { type: 'number', description: 'The maximum number of findings to return. Defaults to 10 unless the user asks for a count.' },
        },
        required: [],
      },
    },
  },
  {
      type: 'function',
      function: {
          name: 'analyze_vulnerability_data',
          description: "Performs advanced analysis and aggregation on vulnerability data. Use this for complex, high-level questions about 'which is best/worst', 'compare', 'what is the risk', 'what is the trend', or 'prioritize'. Do not use for simple 'list' or 'count' questions.",
          parameters: {
              type: 'object',
              properties: {
                  productName: { type: 'string', description: "(Optional) The name of a single product OR a comma-separated list of product names to focus the analysis on. If omitted, the analysis will cover ALL products." },
                  analysisType: {
                      type: 'string',
                      description: 'The type of analysis to perform.',
                      enum: [
                          'component_risk', // For questions like "Which component should I fix first?" or "Which component has the most critical vulnerabilities?"
                          'tool_comparison', // For "Compare tool X and tool Y" or "Which tool finds more issues?"
                          'vulnerability_age', // For "Which is the oldest vulnerability?"
                          'cross_product_component_usage', // For "Which component is shared and vulnerable across products X and Y?"
                      ]
                  },
                  severities: {
                      type: 'array',
                      items: { type: 'string' },
                      description: "A list of severities to include in the analysis (e.g., ['Critical', 'High'])."
                  },
                  limit: { type: 'number', description: 'The number of results to return for ranked lists (e.g., top 5 components). Default is 5.' }
              },
              required: ['analysisType'],
          },
      },
  },
];


export async function answerVulnerabilityQuestions(input: AnswerVulnerabilityQuestionsInput): Promise<AnswerVulnerabilityQuestionsOutput> {
  const MEDTRONIC_GPT_API_URL = process.env.MEDTRONIC_GPT_API_URL;
  const MEDTRONIC_GPT_SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;

  if (!MEDTRONIC_GPT_API_URL || !MEDTRONIC_GPT_SUBSCRIPTION_KEY) {
    return {
      answer: "Error: Medtronic GPT API credentials are not configured. Please set the MEDTRONIC_GPT_API_URL and MEDTRONIC_GPT_SUBSCRIPTION_KEY environment variables in your .env file."
    };
  }
  
  try {
    const validApiToken = await getValidMedtronicGptToken();

    const messages: any[] = [
        {
          role: 'system',
          content: `You are DojoGPT, an expert vulnerability management assistant. Your primary goal is to provide precise, actionable answers to user questions about security vulnerabilities in DefectDojo.

**Core Task & Tool Usage Philosophy:**
- **Be direct.** If the user asks to "list," "show," or "count" something, use the \`get_findings\` tool to fetch the raw data and present it clearly. Do not summarize if the user asks for a list.
- **Be analytical.** If the user asks "which," "why," "compare," or asks for a recommendation, use the powerful \`analyze_vulnerability_data\` tool to perform server-side analysis and provide a high-level summary.
- **Always state the scope** of your answer (e.g., "In product MCLS...", "Across all products...").

**Tool Selection Guide (Examples):**

**Use \`get_findings\` for:**
- *Specific Lists:* "List all critical vulnerabilities in MCLS." -> \`get_findings({productName: 'MCLS', severity: 'Critical'})\`
- *Simple Counts:* "How many high severity issues are in Patient Connector?" -> \`get_findings({productName: 'Patient Connector', severity: 'High'})\` and then count the results.
- *Filtered Queries:* "Show me vulnerabilities related to openssl in Carelink Network." -> \`get_findings({productName: 'Carelink Network', componentName: 'openssl'})\`
- *Tool-Specific Lists:* "List vulns found by SonarQube in MCLH." -> \`get_findings({productName: 'MCLH', toolName: 'SonarQube'})\`

**Use \`analyze_vulnerability_data\` for:**
- *Risk & Prioritization:* "Which component in MCLS should be fixed first?" -> \`analyze_vulnerability_data({analysisType: 'component_risk', productName: 'MCLS'})\`
- *Comparisons:* "Compare Jfrog and DependencyTrack in MyCareLink." -> \`analyze_vulnerability_data({analysisType: 'tool_comparison', productName: 'MyCareLink'})\`
- *Cross-Product Analysis:* "Which vulnerable component is shared between CLEM and MCLH?" -> \`analyze_vulnerability_data({analysisType: 'cross_product_component_usage', productName: 'CLEM,MCLH'})\`
- *Trends & Aging:* "Which is the oldest vulnerability in Patient Connector?" -> \`analyze_vulnerability_data({analysisType: 'vulnerability_age', productName: 'Patient Connector'})\`

**Response Formatting Rules:**
- Use Markdown.
- Use **bold text** for headings and key terms. DO NOT use Markdown headers ('#', '##').
- When listing findings from \`get_findings\`, present them in a numbered list. For each finding, include the **Title**, **Severity**, **Component**, **CVE**, and **CWE**.
- When presenting analysis from \`analyze_vulnerability_data\`, provide a clear **Analysis Summary** followed by a **Recommendation**.

**Final Answer Generation:**
- After getting data from a tool, analyze it and form a complete, human-readable answer.
- If a tool returns no results, clearly state that (e.g., "I found no critical vulnerabilities for product X.") instead of saying you can't perform the action.
- End with a helpful closing remark.`,
        },
        {
          role: 'user',
          content: input.question,
        },
    ];

    const requestBody = {
      messages,
      tools,
      tool_choice: 'auto',
    };

    const response = await fetch(MEDTRONIC_GPT_API_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
        'api-token': validApiToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      if (response.status === 401) {
          tokenCache.expiresAt = 0; // Force a token refresh on the next attempt
          return {
              answer: `Authentication error with Medtronic GPT (HTTP 401). The API token might be invalid. A refresh will be attempted on the next request. Details: ${errorText}`
          };
      }
      return {
          answer: `Error calling Medtronic GPT: HTTP status ${response.status}. ${errorText}`
      };
    }

    const data = await response.json();
    const responseMessage = data.choices && data.choices[0] && data.choices[0].message;

    // Check if the model wants to call a tool
    if (responseMessage && responseMessage.tool_calls) {
        messages.push(responseMessage);
        
        for (const toolCall of responseMessage.tool_calls) {
            const functionName = toolCall.function.name;
            const args = JSON.parse(toolCall.function.arguments);
            let toolResponseContent = '';


            try {
                 switch (functionName) {
                    case 'get_findings':
                        toolResponseContent = await getFindings(args);
                        break;
                    case 'analyze_vulnerability_data':
                        const analysisResult = await analyzeVulnerabilityData(args.analysisType, args.productName, args.severities, args.limit);
                        toolResponseContent = JSON.stringify(analysisResult);
                        break;
                    default:
                        toolResponseContent = JSON.stringify({ error: `The tool '${functionName}' is not recognized.` });
                }
            } catch (e) {
                const error = e instanceof Error ? e.message : String(e);
                toolResponseContent = JSON.stringify({ error: `An error occurred while running the tool: ${error}` });
            }

            messages.push({
                tool_call_id: toolCall.id,
                role: 'tool',
                name: functionName,
                content: toolResponseContent,
            });
        }
            
            const secondRequestBody = { messages, tools, tool_choice: 'auto' };
            const secondResponse = await fetch(MEDTRONIC_GPT_API_URL, {
                method: 'POST',
                headers: {
                    'api-version': '3.0',
                    'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
                    'api-token': validApiToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(secondRequestBody),
            });
            
            if (!secondResponse.ok) {
              const errorText = await secondResponse.text();
              return { answer: `Error processing tool result: HTTP status ${secondResponse.status}. ${errorText}` };
            }
            
            const secondData = await secondResponse.json();
            const finalAnswer = secondData.choices && secondData.choices[0] && secondData.choices[0].message && secondData.choices[0].message.content
                ? secondData.choices[0].message.content
                : "I couldn't process the data from DefectDojo.";

            return { answer: finalAnswer };
    }


    const answer = responseMessage && responseMessage.content
      ? responseMessage.content
      : "I'm sorry, I received an unexpected response from Medtronic GPT.";

    return { answer };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      answer: `There was a problem processing your request. Please check your configuration. Details: ${errorMessage}`
    };
  }
}

    
    