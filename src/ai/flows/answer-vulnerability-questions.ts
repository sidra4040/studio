
'use server';
/**
 * @fileOverview A vulnerability management chatbot that uses the Medtronic GPT and can query DefectDojo.
 *
 * - answerVulnerabilityQuestions - A function that answers questions using Medtronic GPT, with the ability to call tools.
 * - AnswerVulnerabilityQuestionsInput - The input type for the answerVulnerabilityQuestions function.
 * - AnswerVulnerabilityQuestionsOutput - The return type for the answerVulnerabilityQuestionsOutput function.
 */

import {z} from 'genkit';
import { getFindings, getProductList, getVulnerabilityCountsByProduct, getTotalFindingCount, getProductVulnerabilitySummary, getToolList, getTopCriticalVulnerabilityPerProduct, getComponentImpact, getTopRiskyComponents } from '@/services/defectdojo';


const AnswerVulnerabilityQuestionsInputSchema = z.object({
  question: z.string().describe('The question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsInput = z.infer<typeof AnswerVulnerabilityQuestionsInputSchema>;

const AnswerVulnerabilityQuestionsOutputSchema = z.object({
  answer: z.string().describe('The answer to the question about vulnerability management.'),
});
export type AnswerVulnerabilityQuestionsOutput = z.infer<typeof AnswerVulnerabilityQuestionsOutputSchema>;

// In-memory cache for the Medtronic GPT token
const tokenCache = {
  apiToken: process.env.MEDTRONIC_GPT_API_TOKEN || null,
  expiresAt: 0, // A value of 0 forces a refresh on the first call
};

/**
 * Refreshes the Medtronic GPT API token.
 * This function is called when the current token is missing or expired.
 */
async function refreshMedtronicGptToken(): Promise<string> {
  const REFRESH_URL = process.env.MEDTRONIC_GPT_REFRESH_URL;
  const SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;
  const REFRESH_TOKEN = process.env.MEDTRONIC_GPT_REFRESH_TOKEN;
  const currentApiToken = tokenCache.apiToken; // Use the possibly expired token for the refresh call

  if (!REFRESH_URL || !SUBSCRIPTION_KEY || !REFRESH_TOKEN || !currentApiToken) {
    throw new Error('Missing Medtronic GPT refresh credentials. Please set MEDTRONIC_GPT_REFRESH_URL, MEDTRONIC_GPT_SUBSCRIPTION_KEY, MEDTRONIC_GPT_REFRESH_TOKEN, and an initial MEDTRONIC_GPT_API_TOKEN in your .env file.');
  }
  
  try {
    const response = await fetch(REFRESH_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': SUBSCRIPTION_KEY,
        'api-token': currentApiToken,
        'refresh-token': REFRESH_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      const errorText = await response.text();
      tokenCache.apiToken = null;
      tokenCache.expiresAt = 0;
      throw new Error(`Failed to refresh token: HTTP status ${response.status}. ${errorText}`);
    }
    
    const data = await response.json();
    const newApiToken = data.apiToken || data.token;
    
    if (!newApiToken) {
        throw new Error("New API token not found in the refresh response payload.");
    }
    
    tokenCache.apiToken = newApiToken;
    // Set expiry to 3600 seconds (1 hour) from now, with a 60-second buffer
    tokenCache.expiresAt = Date.now() + (3600 - 60) * 1000;
    
    return newApiToken;
  } catch (error) {
    tokenCache.apiToken = null;
    tokenCache.expiresAt = 0;
    throw error;
  }
}

/**
 * Retrieves a valid Medtronic GPT API token, refreshing it if necessary.
 */
async function getValidMedtronicGptToken(): Promise<string> {
  const isTokenExpired = Date.now() >= tokenCache.expiresAt;
  
  if (tokenCache.apiToken && !isTokenExpired) {
    return tokenCache.apiToken;
  }
  
  return await refreshMedtronicGptToken();
}

// New, more specific tool definitions
const tools = [
  {
    type: 'function',
    function: {
      name: 'get_findings',
      description: "Get vulnerability findings from DefectDojo. Can be filtered by `productName`, `toolName`, or both. A `productName` is NOT required if a `toolName` is provided, and vice-versa. For example, to find all critical vulnerabilities from the 'Rapid7' scanner, call this tool with `toolName: 'Rapid7'`. To find vulnerabilities for the 'WebApp' product, call with `productName: 'WebApp'`. You can also combine them to find vulnerabilities for a specific product from a specific tool.",
      parameters: {
        type: 'object',
        properties: {
          productName: {
            type: 'string',
            description: "(Optional) The name of the product (e.g., 'CLEM', 'MCLS') to filter findings by. Use this for product-specific queries.",
          },
          severity: {
            type: 'string',
            description: "The severity level to filter by (e.g., 'Critical', 'High').",
          },
          active: {
              type: 'boolean',
              description: 'Filter by active or inactive findings. Defaults to active if not specified.'
          },
          limit: {
              type: 'number',
              description: 'The maximum number of findings to return. Defaults to 10.'
          },
          toolName: {
            type: 'string',
            description: "(Optional) The name of the tool/scanner (e.g., 'Rapid7', 'Sonarqube', 'CloudGuard') to filter findings by. Use this for tool-specific queries.",
          },
        },
        required: [], // All params are optional
      },
    },
  },
  {
    type: 'function',
    function: {
        name: 'get_product_list',
        description: 'Get a list of all product names available in DefectDojo. Use this when the user asks for "all products" or to list the products.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_tool_list',
        description: 'Get a list of all tool/scanner names (Test Types) from DefectDojo. Use this when the user asks to "list all tools" or to see available scanners.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_vulnerability_count_by_severity',
        description: 'Get a breakdown of active vulnerability counts by severity for a specific product. Use this when asked for counts, totals, or distribution of vulnerabilities for a product.',
        parameters: {
            type: 'object',
            properties: {
                productName: {
                    type: 'string',
                    description: 'The name of the product to get vulnerability counts for.'
                }
            },
            required: ['productName']
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_total_findings_count',
        description: 'Get the total number of all findings (vulnerabilities) in the system. Use this when asked for "total findings" or "how many findings".',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_product_vulnerability_summary',
        description: 'Get a summary of vulnerability counts (Critical, High, etc.) for all products. Use this to determine which product has the most vulnerabilities of a certain severity.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_top_critical_vulnerability_per_product',
        description: 'Get the single most critical vulnerability for each product in the system. Use this when the user asks for a summary or one example vulnerability from every product.',
        parameters: {
            type: 'object',
            properties: {},
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_component_impact',
        description: "Analyzes the impact of fixing all vulnerabilities for a specific software component, such as 'OpenSSL', 'libxml2', or 'jQuery'. Use this when the user asks 'how many vulnerabilities if we fix X' or 'what is the risk reduction for X'.",
        parameters: {
            type: 'object',
            properties: {
                componentName: {
                    type: 'string',
                    description: "The name of the software component to analyze (e.g., 'openssl')."
                }
            },
            required: ['componentName']
        }
    }
  },
  {
    type: 'function',
    function: {
        name: 'get_top_risky_components',
        description: "Identifies the software components that contribute the most to overall risk. Can be filtered by a specific product. Use this when the user asks 'what should we fix first?', 'what are the riskiest components?', or asks for a general prioritization plan. If a product is mentioned (e.g., 'in 24967' or 'for CLEM'), provide the `productName`.",
        parameters: {
            type: 'object',
            properties: {
                productName: {
                    type: 'string',
                    description: "(Optional) The name or ID of the product to scope the analysis to (e.g., 'CLEM', '24967'). If not provided, the analysis will cover all products."
                }
            },
        }
    }
  }
];


export async function answerVulnerabilityQuestions(input: AnswerVulnerabilityQuestionsInput): Promise<AnswerVulnerabilityQuestionsOutput> {
  const MEDTRONIC_GPT_API_URL = process.env.MEDTRONIC_GPT_API_URL;
  const MEDTRONIC_GPT_SUBSCRIPTION_KEY = process.env.MEDTRONIC_GPT_SUBSCRIPTION_KEY;

  if (!MEDTRONIC_GPT_API_URL || !MEDTRONIC_GPT_SUBSCRIPTION_KEY) {
    return {
      answer: "Error: Medtronic GPT API credentials are not configured. Please set the MEDTRONIC_GPT_API_URL and MEDTRONIC_GPT_SUBSCRIPTION_KEY environment variables in your .env file."
    };
  }
  
  try {
    const validApiToken = await getValidMedtronicGptToken();

    const messages: any[] = [
        {
          role: 'system',
          content: `You are DojoGPT, an expert vulnerability management assistant. Your primary goal is to help security teams **prioritize vulnerabilities and reduce risk** by providing clear, actionable summaries and mitigation strategies.

**New Capability: Component Impact Analysis**
- If the user asks about the impact of fixing a **specific component** (e.g., "what if we fix openssl?" or "how much risk is reduced by patching libxml2?"), you MUST use the \`get_component_impact\` tool.
- When you get the results, present them clearly. For example: "Fixing all vulnerabilities in **OpenSSL** would resolve **50 issues** (including 10 Critical and 15 High severity ones) and would **reduce your overall risk exposure by 15.5%**."
- **After the summary, you MUST include a list of sample critical vulnerabilities if they are provided in the tool's output (\`sampleVulnerabilities\` array).** Use a bold heading like '**Sample Vulnerabilities**' and list each one with its title, severity, CVSS score, and CWE.
- If the user asks a general question about **what to fix first** or for the **riskiest components**, you MUST use the \`get_top_risky_components\` tool.
- If the user's question about prioritization includes a specific product name or ID (e.g., "in CLEM", "for product 24967"), you MUST pass that product name to the 'productName' parameter of the 'get_top_risky_components' tool.
- When presenting the top risky components, list them in order and explain why they are a priority (e.g., "The top priority should be **libxml2**, as fixing it would reduce your overall risk by over 25%.").

**Core Task:**
- Analyze user queries to see if they are about a 'product' (e.g., 'CLEM') or a 'tool' (e.g., 'Rapid7', 'Sonarqube'). Use the correct tool parameters for the search.
- When you get vulnerability data back, analyze it and present a clear summary. Don't just list the raw data. Group related findings where possible (e.g., multiple CVEs for one component).
- **Prioritize findings based on severity and potential impact (CVSS score).**

**Formatting Rules (Strictly Follow):**
- Use Markdown.
- Use **bold text** for headings. DO NOT use Markdown headers ('#', '##').
- Use numbered lists for main findings and bullet points for details.

**Response Structure:**
1.  **Introduction**: Start with a friendly confirmation and state what you found (e.g., "Certainly! I found X critical findings for product Y. Here is a summary of the highest-priority issues:").
2.  **Findings Summary**: A bold heading like '**Vulnerability Summary**'.
3.  **Vulnerability List**: A numbered list of the most critical vulnerabilities. Each item should be a bold component name or finding title. Use sub-bullets for details like 'Finding ID', 'Issue', 'CVSS', 'Impact', 'CWE'.
4.  **Prioritized Action Plan**: A bold heading like '**Prioritized Action Plan**'.
5.  **Action List**: A bulleted list of clear, prioritized remediation steps designed to reduce the most risk first. **If mitigation steps are not provided in the data, you MUST generate detailed, expert-level remediation advice based on the vulnerability's title, CWE, and type.** For example, for a SQL injection, recommend using parameterized queries or ORMs. For an outdated library, specify the version to upgrade to.
6.  **Closing**: End with a helpful closing remark (e.g., "Addressing these top issues first will significantly reduce your risk exposure. Would you like details on other findings?").

**Example Response:**

Certainly! I found 40 critical findings for CLEM. Here's a summary of the highest-priority issues:

**Vulnerability Summary**

1.  **libpng Component**
    - **Finding ID**: 1928
    - **Issue**: Improper chunk length checks in libpng before version 1.6.32.
    - **CVSS**: 9.8
    - **Impact**: Potential for denial of service.

2.  **libxml2 Component (Grouped)**
    - **Finding ID**: 1940 - CVE-2017-7376 (Buffer overflow) - **CVSS**: 9.8
    - **Finding ID**: 1941 - CVE-2016-4658 (Use-after-free) - **CVSS**: 9.8

**Prioritized Action Plan**
- **Priority 1: Patch \`libxml2\`**. This component has multiple critical use-after-free and buffer overflow vulnerabilities (CVE-2017-7376, CVE-2016-4658). These pose the highest risk of remote code execution. **Remediation**: Upgrade \`libxml2\` to version 2.9.5 or later immediately.
- **Priority 2: Patch \`libpng\`**. The improper chunk length check (Finding 1928) can lead to a denial of service, impacting availability. **Remediation**: Upgrade \`libpng\` to version 1.6.32 or later.

Addressing these top issues first will significantly reduce your risk exposure. Would you like details on other findings?`,
        },
        {
          role: 'user',
          content: input.question,
        },
    ];

    const requestBody = {
      messages,
      tools,
      tool_choice: 'auto',
    };

    const response = await fetch(MEDTRONIC_GPT_API_URL, {
      method: 'POST',
      headers: {
        'api-version': '3.0',
        'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
        'api-token': validApiToken,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      if (response.status === 401) {
          tokenCache.expiresAt = 0; // Force a token refresh on the next attempt
          return {
              answer: `Authentication error with Medtronic GPT (HTTP 401). The API token might be invalid. A refresh will be attempted on the next request. Details: ${errorText}`
          };
      }
      return {
          answer: `Error calling Medtronic GPT: HTTP status ${response.status}. ${errorText}`
      };
    }

    const data = await response.json();
    const responseMessage = data.choices && data.choices[0] && data.choices[0].message;

    // Check if the model wants to call a tool
    if (responseMessage && responseMessage.tool_calls) {
        messages.push(responseMessage);
        
        for (const toolCall of responseMessage.tool_calls) {
            const functionName = toolCall.function.name;
            const args = JSON.parse(toolCall.function.arguments);
            let toolResponseContent = '';


            try {
                 switch (functionName) {
                    case 'get_findings':
                        toolResponseContent = await getFindings(args.productName, args.severity, args.active, args.limit, args.toolName);
                        break;
                    case 'get_product_list':
                        const products = await getProductList();
                        toolResponseContent = JSON.stringify(products);
                        break;
                    case 'get_tool_list':
                        const tools = await getToolList();
                        toolResponseContent = JSON.stringify(tools);
                        break;
                    case 'get_vulnerability_count_by_severity':
                        const counts = await getVulnerabilityCountsByProduct(args.productName);
                        toolResponseContent = JSON.stringify(counts);
                        break;
                    case 'get_total_findings_count':
                        const totalCount = await getTotalFindingCount();
                        toolResponseContent = JSON.stringify(totalCount);
                        break;
                    case 'get_product_vulnerability_summary':
                        const summary = await getProductVulnerabilitySummary();
                        toolResponseContent = JSON.stringify(summary);
                        break;
                    case 'get_top_critical_vulnerability_per_product':
                        toolResponseContent = await getTopCriticalVulnerabilityPerProduct();
                        break;
                    case 'get_component_impact':
                        toolResponseContent = JSON.stringify(await getComponentImpact(args.componentName));
                        break;
                    case 'get_top_risky_components':
                        toolResponseContent = JSON.stringify(await getTopRiskyComponents(5, args.productName));
                        break;
                    default:
                        toolResponseContent = JSON.stringify({ error: `The tool '${functionName}' is not recognized.` });
                }
            } catch (e) {
                const error = e instanceof Error ? e.message : String(e);
                toolResponseContent = JSON.stringify({ error: `An error occurred while running the tool: ${error}` });
            }

            messages.push({
                tool_call_id: toolCall.id,
                role: 'tool',
                name: functionName,
                content: toolResponseContent,
            });
        }
            
            const secondRequestBody = { messages, tools, tool_choice: 'auto' };
            const secondResponse = await fetch(MEDTRONIC_GPT_API_URL, {
                method: 'POST',
                headers: {
                    'api-version': '3.0',
                    'subscription-key': MEDTRONIC_GPT_SUBSCRIPTION_KEY,
                    'api-token': validApiToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(secondRequestBody),
            });
            
            if (!secondResponse.ok) {
              const errorText = await secondResponse.text();
              return { answer: `Error processing tool result: HTTP status ${secondResponse.status}. ${errorText}` };
            }
            
            const secondData = await secondResponse.json();
            const finalAnswer = secondData.choices && secondData.choices[0] && secondData.choices[0].message && secondData.choices[0].message.content
                ? secondData.choices[0].message.content
                : "I couldn't process the data from DefectDojo.";

            return { answer: finalAnswer };
    }


    const answer = responseMessage && responseMessage.content
      ? responseMessage.content
      : "I'm sorry, I received an unexpected response from Medtronic GPT.";

    return { answer };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      answer: `There was a problem processing your request. Please check your configuration. Details: ${errorMessage}`
    };
  }
}
